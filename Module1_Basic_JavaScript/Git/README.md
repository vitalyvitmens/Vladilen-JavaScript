1. git status - глянуть статус, показывает что у нас сейчас происходит в рабочем дереве гита, дает более оперативную инфу чем VS-code
2. git add [files] || git add [folder] || git add . - добавляет файлы в stage (этап = промежуточная область)
3. git commit -m "comment" - закомитить файлы добавленные в stage (этап = промежуточная область)
4. git commit -m "comment" -a || git commit -m "comment" --all - закоммитить всё что у нас есть
5. git log - глянуть подробную инфу (логи) о наших коммитах, на каком комите находимся, где у нас находится main ветка. Клавиша q - выйти из git log
6. git log --oneline - глянуть краткие логи коммитов (id коммита + название коммита)
7. git config user.name - глянуть автора
8. git config user.email - глянуть почту автора
9. git remote -v - узнать есть ли удаленный репозиторий
10. git remote origin url - привязать локальный гит к удаленному (github) гиту
11. git push [rep_link] [branch_name] || git push
- [rep_link] = git remote -v = origin = https://github.com/vitalyvitmens/Vladilen-JavaScript
- [branch_name] = git branch = main
- gip push origin main
12. git reset [files] - что бы убрать со stage определенный файл 
13. git diff - посмотреть изменения
14. git reset --hard - уберет все изменения и вернет то что было до последнего push
15. git restore [files] - уберет все изменения в файле и вернет то что было до последнего коммита в этой ветке
16. git restore --staged [file] - выбросит файл из коммита

### Правильное оформление коммитов https://www.conventionalcommits.org/en/v1.0.0/

<type>(optional scope): <description>
[optional body]
[optional footer(s)]
feat: | fix: | docs: | chore: 

1. В терминале открываем терминал powershell || bash || zsh и пишем команду: git commit -a
2. В открывшемся новом окне редактора кода пишем коммит состоящий из header body footer:
3. Основные типы коммитов:
  - feat:
  - fix:
Пример: fix(Module1_Basic_JavaScript\Git\README): изменяет текст

4. Рекомендуемые типы коммитов:
  - build: если чтото поменялось в сборке
  - chore: если не поменялось ничего важного для работы Вашего проекта (поправили орфографические ошибки в комментариях)
  - ci: если поменялось чтото в сборке
  - docs: изменения в документации
  - style: изменения в стилях
  - refactor: какие то рефакторинги
  - perf: работа над скоростью проекта
  - test: изменение автотество внутри нашего проекта
Пример: docs(Module1_Basic_JavaScript\Git\README): добавляет текст в главе Правильное оформление коммитов

Мы можем указывать в футоре BREAKING CHANGE: или ! у типа или у scope (например fix!:) если мы чтото поменяли что делает использовнаие нашего проекта не возможным для тех кто использует старую версию, например часто бывает при разработке библиотек (например библиотеку компонентов)

3. Что бы редактор кода открывался в новом окне после команды git commit -a, настраиваем редактор запуском команды в терминале:
git config --global core.editor "code --wait -n"
Еще может понадобиться настроить VS-Code: VS-code => Ctrl + Shift + p => PATH => Shell command: Install 'code' command in PATH => перезагрузить VS-code

### Откатить commit например если забыл создать файл .gitignore и сдуру запушил лишнего
1. git rm -rf --cached .
2. git add .
3. git commit -m "fix gitignore"

### Что бы git перестал отслеживтаь какой то файл
1. git rm --cached [files]

### Что бы сохранить наши изменения и временно работать на версии кода без этих изменений
1. git add . - добавляем все наши изменения
2. git stash - убирает (откатывает) наши изменения в stash (временное хранилище куда можно перевести все отслеживаемые файлы, перед этим их обязательно нужно добавить при помощи git add .)
3. git stash list - что бы заглянуть внутрь stash (временного хранилища)
4. git stash pop - возвращает наши изменения, вытаскиваем последнюю запись из stash, что бы их закомитить после вытаскивания используй команду git add .
5. git stash pop - удалить из stash последнюю запись
6. git stash drop - удалить все записи из stash
7. git stash apply - применить изменения не удаляя изменения из stash
8. git stash apply stash@{0} - применить нулевую запись находящуюся в stash, перед этим посмотри идентификатор нужной записи (stash@{0}) при помощи команды git stash list


### Редактирование коммитов в том числе ошибочных коммитов
1. git commit --amend - флаг --amend позволяет как то поменять коммит + может менять и код вместе с изменением коммита, но он годится только для одного разработчика, разрабатывающего только на одном компьютере
2. git commit --amend --no-edit - меняет код без изменения названия коммита, но он годится только для одного разработчика, разрабатывающего только на одном компьютере
3. git log - посмотреть успешность изменения коммита и др инфу, обрати внимание хэш коммита тоже меняется, поэтому это не годится для коммандной разработки или одиночной, но на нескольких устройствах

### Как работает git: папка .git
1. ls -la - выполните команду в терминал Git bash, что бы увидеть все файлы git и полную информацию о них
2. code .git - открывает папку .git в редакторе кода, откроются папки гита:
  - hooks - папка хранит файлы выполняемые на какие то события, например перед коммитом, перед пушем и тд
  - info - папка в которой хранится файл exclude, в нем можно указть какие то файлы которые будут работать как .gitignore
  - logs - в этой папке хранится лог всех событий, в файле HEAD хранится все что происходило
  - Objects - это хранилище гита, не удалять, а то сломается гит
  - refs - в этой папаке хранится информация, о том куда указывают разные ветки, например ветка main (.git/refs/heads/main) указывает на коммит хэшом коммита, например: aacd1343734c92cff53e084d1e512327b7fd25fa, можно перейти в терминал и выполнить git log затем скопировать хэш коммита и убедиться что он аналогичен данному хэшу ветки main
  - COMMIT_EDITMSG - это файл, содержащий последнее сообщение коммита которое мы редактировали
  - config - файл различных конфигураций
  - description - описание для репозитория если, именованный репозиторий есть
  - HEAD - указывает где мы сейчас находимся ref: refs/heads/main
  - ORIG_HEAD - ссылается на тот же хэш коммита, что и .git/refs/heads/main aacd1343734c92cff53e084d1e512327b7fd25fa
  - index - бинарный файл используемый гитом

### Как смотреть историю: git log
1. git log - увидим хэш коммита, автора коммита, дату создания, описание коммита
2. git log -p - увидим что конкретно было сделано внутри коммита (подходит к атомарным коммитам, когда часто коммитятся малые изменения)
3. git log --stat - что бы узнать насколько большой или маленький был коммит и не хочется смотреть patch
4. git log --pretty=oneline - можно форматировать в каком виде будет предоставлена информация истории коммита (oneline - формат один коммит в одну строку)
5. git log --pretty=format:"%h (%ae): %s" - можно пользовательски форматировать в каком виде будет предоставлена информация истории коммита (%h - хэш коммита, (%ae): - автор коммита, %s - текс коммита)
6. GitLens - расширение в VS-code позволяющее например нарисовать граф коммитов

### Как менять историю коммита: git reset/revert
1. git log - отыскиваем и копируем хэш коммита который следует откатить
2. git revert [hash_commit] - откроется редактор который предложит изменить заготовленное сообщение для этого коммита. НЕ РЕКОМЕНДУЕТСЯ так как добавит новый комит после изменяемого
3. git reset HEAD~1 - откатиться назад на 1 (один) коммит
4. git reset [hash_commit] - откатиться назад к коммиту с хэшом [hash_commit] указанным в команде
5. git reset [hash_commit] --hard - откат назад к коммиту с хэшом [hash_commit] указанным в команде и сброс всех изменений
6. git reset [hash_commit] --soft - ПРЕДПОЧТИТЕЛЬНЫЙ ВАРИАНТ, откат назад к коммиту с хэшом [hash_commit] указанным в команде без потери изменений в Staged Changes с возможностью переложить изменения в другие коммиты
7. git reset [hash_commit] --mixed - ПРЕДПОЧТИТЕЛЬНЫЙ ВАРИАНТ, откат назад к коммиту с хэшом [hash_commit] указанным в команде с потерей изменений в Staged Changes, но без потери самих изменений 
8. GitLens - расширение в VS-code позволяет откатить коммит нажав на стрелку по кругу

### Как редактировать старые коммиты: git rebase для коммитов
1. Открываем GitLens => COMMITS => Working Tree и копируем [SHA] необходимого коммита
2. git rebase [SHA] -i - задает [SHA] от которого дальше руками будем перестраивать дерево, импользуется для редактирования истории внутри одной ветки или наслаивания ветки на ветку. В VS-code откроет GitLens interactive Rebase который позволит что то делать с коммитами, что бы переключиться на текст SWITCH TO TEXT с описанием всех команд. что бы склеить 2 коммита вместе склеиваемый перемещаем под тот с которым надо склеить и выбираем комнаду pick - если сохранить и закрыть, то коммиты пересортируются в дереве коммитов согласно новым местам, но еще не склеються, для склейки у склеиваемого коммита нужно поменять pick на squash (но остануться 2 строчки коммит месседж) | fixup (как squash, но только выкидывает коммит месседж. ПРЕДПОЧТИТЕЛЬНО)
Если нужно удалить коммит выбираем команду drop - удалит данный коммит
Если нужно редактировать коммит выбираем команду edit
После выбора сохраняем и закрываем, далее мы находимся в процессе ребэйса он еще не закончен, можем добавить что то в коммит, после добавления выполняем git add . + git commit --amend --no-edit, а когда закончили с изменениями выполняем команду git rebase --continue, дальше сталкиваемся с ситуацией когда возникает merge конфликт (коммит не может наложиться на предыдущий), разделителем двух состояний является ============== . Вверху выбираем Accept Both Changes (принять оба изменения убрав все разделители) и далее удаляем, то что не нужно. Сохраняем этот файл. Делаем git add . А затем git rebase --continue Продолжаем ребэйс закрываем файл и ребэсы продолжаются. Открываем GitLens => COMMITS и проверяем что изменения применились.
НЕ ЗАБЫВАЙТЕ в случае работы с одной веткой использовать интерактивный режим -i ребэйса: git rebase [SHA] -i

### Как переключаться между коммитами: git checkout (можно переключаться между коммитами по их хэшу [SHA]) Подходит для тестирования кода проекта, так как режим detached и можно не сохранять изменения и легко вернуться в предыдущее состояние main
1. Открываем GitLens => COMMITS => Working Tree и копируем [SHA] необходимого коммита
2. git checkout [SHA] - перейдем на тот коммит при котором например, по заявлениям коллеги повились баги и проверяем были ли баги при этом коммите или не было. HEAD показывает где во времени коммитов в дереве мы находимся, находимся в режиме detached HEAD (в подвешенном состоянии, когда созданные коммиты будут подвешены в воздухе, можно делать эксперементальные изменения коммитить их изменять для этого применяем команду: git commit -m "chore: описываем что поменяли" -a, это создаст отдельную ветку, отдельно от main и если переключимся обратно на ветку main: git checkout main, то они не применятся, но и не пропадут их можно отыскать в случае необходимости и создать новую ветку git branch [new-name-branch] [SHA] или переключиться на данный коммит снова git checkout [SHA] или создать ветку и переключиться на нее git switch -c [new-name-branch]).

### Как восстанавливать утерянные коммиты: git reflog
1. git reflog - при выполнении данной команды мы увидим в терминале все действия которые у нас происходили, при нахождении нужного нам действия, например не сохраненный коммит, мы можем взять его хэш [SHA] и переключиться на него даже если он не отображается в логе (git log). Даже если мы удалим последний коммит git reset HEAD~1 то всеравно при помощи git reflog мы сможем отыскать этот удаленный коммит
2. git checkout [SHA] - для того что бы переключиться на найденный нами утерянный коммит. 

### Как работать в 2 ветках: git branch vs git checkout
1. git branch [new-name-branch] - создем ветку с названием [new-name-branch]
2. git branch -v - посмотреть все ветки проетка с хэшами и названием коммитов, зеленым подсвечивается та ветка на которой сейчас находимся
3. git checkout [name-branch] - переключиться на ветку с названием [name-branch]
4. git branch -v - проверяем что действительно переключились на нужную ветку
5. например вносим какие изменения в код на данной ветке
6. git commit -m 'указываем изменения' -a - закоммитили изменения в ветке
7. git checkout main - переключаемся на ветку main
8. git branch -d [name-branch] - удаляем ветку с названием [name-branch], в терминале скажут что удалить не возможно, так как в ветке есть коммит, который не добавлен ни в какую другую ветку, если действительно нужно удалить используйте git branch -D [name-branch]
9. git branch -D [name-branch] - теперь точно удаляем ветку с названием [name-branch], в терминале скажут что удалена ветка [name-branch] и укажут ее хэш [SHA]
10. git branch [new-name-branch-2] [SHA] - создаёт ветку [new-name-branch-2] если передать в команду при создании хэш [SHA] удаленной ветки [new-name-branch]
11. git checkout [new-name-branch-2] - переключаемся на ветку [new-name-branch-2]
12. снова вносим какие изменения в код на данной ветке
13. git commit -m 'создаем новый коммит' -a - закоммитили изменения в ветке [new-name-branch-2]
14. git log - проверяем на какой ветке мы находимся, а находимся мы на ветке [new-name-branch-2]
15. git checkout -b [new-name-branch-3] - создаем новую третью ветку [name-branch-3] которая будет указывать на один и тот же коммит, что и ветка [name-branch-2]

### Как объединять ветки: git merge (продолжение параграфа: Как работать в 2 ветках:)
1. git checkout main - переключаемся на ветку main что бы удалить ветку [name-branch-3]
2. git branch -D [name-branch-3] - удаляем ветку [name-branch-3]
3. git merge [name-branch-2] - находясь в main вносим изменения из ветки [name-branch-2] в ветку main (мёрджим ветку [name-branch-2] в main)
4. git log - смотрим где находимся (HEAD -> main, [name-branch-2]) и проверяем что все наши изменения в коде есть
5. Открываем GitLens => COMMITS => Working Tree и видим что main переместился на самый верх, где произошел merge с использовнаием технологии Fast-forward (если можно все коммиты наложить поверх и ничего не сломается, то git использует Fast-forward что бы передвинуть ветку по коммитам, но так не всегда получается, ниже имитируем другой вариант, окатывая main на 2 коммита вниз)
6. git reset HEAD~2 --hard - окатываем main на 2 коммита вниз и вносим изменения в мастер добавляя например немного форматирования и сохраняем
7. git commit -m 'добавили форматировнаие' -a - вносим изменения в мастер добавляя например немного форматирования и сохраняем коммит 
8. теперь мы видим что у нас появилось ветвление у нас 2 ветки отходят от коммита, это ветки [name-branch-2] с двумя коммитами и main с одним коммитом. Теперь делаем тот самый merge, но технология Fast-forward уже не поможет
9. git merge [name-branch-2] - снова находясь в main вносим изменения из ветки [name-branch-2] в ветку main (мёрджим ветку [name-branch-2] в main), откроется редактор сообщений для коммита, так как создается новый коммит и мы меняем сообщение например пишем: мы вливаем ветку [name-branch-2], сохраняем и закрываем и видим что в истории был изначальный коммит затем добавился коммит [name-branch-2] потом добавился еще один коммит после этого произошел коммит в main и затем merge коммит
10. git log - смотрим как это выглядит в логе (HEAD -> main) Что куда влилось по хэшам. Merge: [SHA-main] [SHA-name-branch-2]
11. git branch -D [name-branch-2] - удаляем ветку name-branch-2, но в истории ветка [name-branch-2] всеравно останется, но переключение на [name-branch-2] не удастся, но в случае чего мы можем создать ветку [name-branch-2] обратно, для этого выполняем: git log и копируем оттуда хэш [SHA-name-branch-2] ветки которую нужно создать, второе значение в Merge: [SHA-main] [SHA-name-branch-2]
12. git branch [new-name-branch-2] [SHA-name-branch-2] - воссоздаем по хэшу удаленную ветку [SHA-name-branch-2]
13. git reset HEAD~2 - можем откатить изменение на нужный коммит например как сейчас на 2 коммита назад, но нужно помнить что влитие изменений из одной ветки создает ровно один merge-коммит и нам достаточно откатиться только на один коммит. Fast-forward не создает merge-коммит

### Как обновлять ветку по мастеру: git rebase для веток
1. Как сделать так что бы ветка [name-branch-2] отводилась от верхнего коммита main:
2. git checkout [name-branch-2] - переключаемся на ветку [name-branch-2]
3. git rebase main - этой командой мы говорим, что все коммиты в текущей ветке [name-branch-2] нужно поставить сверху ветки main
4. Открываем GitLens => COMMITS => Working Tree и видим что начальный коммит ветки [name-branch-2] стал последним коммитом для ветки main
5. git rebase main -i - гит ребэйс можно выполнять в интерактивном режиме -i, тогд аоткроется редактор и в нем мы сможем управлять етм как коммиты будут накладываться поверх main, например можно склеить 2 коммита команда fixup сохраняем интерактивное окно и закрываем. При этом 2 коммита склеяться в один и наложаться поверх main и при мредже [name-branch-2] в main у нас будет возможен merge с использовнаием технологии Fast-forward (просто премещение указателя в main с последнего коммита main на коммит [name-branch-2])
6. git checkout main - переключаемся на main
7. git merge [name-branch-2] - смердживаем [name-branch-2] в main. Сработает Fast-forward (просто премещение указателя в main с последнего коммита main на коммит [name-branch-2]) и теперь в main есть наш коммит [name-branch-2]
8. Ребэйс полезно использовать в реальных проектах когда мы хотим проверить, что те изменения которые мы делали неделю вмерджатся в main и ничего не сломается и когда мы хотим пользоваться Fast-forward-ом который вмердживает без дополнительных merge-коммитов или добавлять изменения из main к нам в ветку без дополнительных коммитов, то отребэйзиваем нашу ветку по основной ветке  main
9. Возможны merge-конфликты, но это хорошо, так как они будут сразу обнаруживаться и разрешаться при вливании нашей ветки в основную
10. Рекомендуется использовать ребэйсом когда пользуешься веткой один

### Как брать только часть изменений из ветки: git cherry-pick
1. git checkout -b test - создаем новую ветку test и работаем в ней, добавили текст
2. git commit -m 'добавили текст' -a - создали коммит
3. Открываем GitLens => COMMITS => Working Tree и видим что коммит test преместился на 1 коммит вверх main 
4. git checkout main - переключаемся на мастер
5. git checkout -b test2 - после этого коллега создал ветку test2 и закоммитил изменения, которые все ломают, мы просим его пофиксить изменения 
6. коллега исправляет и коммитит эти изменения и говорит заберай этот фикс к себе передает хэш коммита [SHA], я волью эти изменения позже, нам нужно влить именно эти изменения
7. git checkout test - переключаемся на ветку test
8. git cherry-pick [SHA] - передаем хэш коммита [SHA] который мы хотим скопировать, нам не важно у него подвешенное состояние или он в ветке, создается копия коммита в нашей ветке точно стакими изменениями но с другим хэшем коммита [SHA]
9. git checkout main - переключаемся на мастер
10. git merge test - если мы мерджим test в main, то все изменения добавятся в main при помощи Fast-forward
11. git merge test2 - если мы мерджим test2 в main, то будет merge-conflicts, так как мы в двух разных ветках меняли одну и ту же строчку. 
12. принимаем оба изменения Accept Both Changes лишнее убираем, тот код что нужно оставить копируем. Мы разрешили merge-conflicts, добавили файл в Staged Changes и закоммитили
13. git log - в истории увидим 2 одинаковых коммита но разнэе по хэшам, нужно избавляться от такого выполняя ребэйс перед тем как мерджиться ветка в другую ветку
14. git branch [SHA-test] - возращаем ветку test
14. git branch [SHA-test2] - возращаем ветку test2
15. git reset [SHA] - откатываем Main снова на нужный коммит и убираем все изменния стрелкой по кругу
16. git merge test - сначала мерджим в main test
17. git checkout test2 - переключаемся на test2
18. git rebase main - видим merge-conflicts решаем его принимаем оба изменения Accept Both Changes лишнее убираем, тот код что нужно оставить копируем
19. git add .
20. git rebase --continue - сохраняем интерактивное окно и закрываем
21. git log - в истории видим что в test2 остался только один коммит, черепикнутый коммит был склеен
22. git checkout main
23. git merge test2 - теперь при мердже test2 в main сработает Fast-forward и не будет merge-conflicts 
24. при выполнении команды git cherry-pick постарайтесь ребэйзить ваши ветки перед тем как вы будете их вливать с помощью git merge

### Как присоединять несколько удалённых репозиториев: git remote (позволяет управлять удалёнными репозиториями)
1. git remote -v - данная команда показывает наличие удаленных (находящихся на расстоянии, например на GitHub) репозиториев
2. git remote add origin [URL] - если нет удаленных репозиториев добавляем их при помощи комнады add, задем имя удаленному репозиторию: origin
3. git remote set-url origin [URL_без_опечатки] - в случае добавления URL с опечаткой, можем поменять URL на правильный данной командой
4. git remote -v - проверяем что теперь URL нашего репозитория правильный без опечатки
5. git remote rename origin main - что бы переназвать (задать другое название репозиторию вместо origin, например задаем main). [name_репозитория] = main
6. git remote -v - проверяем что теперь наш репозиторий называется не origin, а main. Но для основного всегда используйте имя origin, а для всех остальных давайте осмысленные названия, что бы понимать с чем сейчас, конкретно Вы работаете
7. git remote add my-fork [URL] - можно подключить несколько удаленных репозиториев, ели есть желание создать личный клон (fork) удаленного репозитория и в этом клоне как то доработать код, а после этого попытаться влить изменения в основной репозиторий. [name_репозитория] = my-fork
8. git remote rm [name_репозитория] - если нам не нужен какой то удаленный репозиторий мы можем его удалить из наших подключений. [name_репозитория] = my-fork | origin | main
9. git remote rename main origin - переназываем удаленный репозиторий с имени main обратно в имя origin-

### Как отправлять и получать изменения: git push (позволяет отправить изменения) & git pull (позволяет получить изменения и сазу их применить)
1. git push - отправляем изменения с локального компьютера на удаленный сервер
2. git fetch - получаем информацию с удаленного репозитория о всех изменениях которые только существуют в этом удаленном репозитории, при этом локальный master (main) останентся там где и был в дереве коммитов. Данная команда позволяет получить, но не применять изменения
3. git pull - данная команда выполняет git fetch, а дальше переключит состояние нашей локальной ветки где мы находимся на актуальное, будет ошибка так как git не уверен что master (main) и master (main) - это две одинаковые ветки и просит явно указать git pull [remote] [branch] или git branch --set-upstream-to=origin/[branch] master ПРЕДПОЧТИТЕЛЬНЫЙ вариант, так как ее нужно будет выполнить только 1 раз, далее начнет срабатывать без ошибки команда git pull
4. git branch --set-upstream-to=origin/main main - данной командой говорим, что origin/main это тоже самое, что наш локальный main, при этом наш локальный main переключится на самый последний коммит из удаленного main и мы синхронизируем состояние наших веток
5. git push --all - что бы запушить в удаленный репозиторий все ветки, не только main которые есть
6. git checkout [name_branch] - что бы переключиться на ветку [name_branch]

### Как подключить нового человека: git clone
1. git remote -v - данная команда показывает наличие удаленных (находящихся на расстоянии, например на GitHub) репозиториев, копируем [URL] и передаем его новому сотруднику
2. git clone [URL] - новый сотрудник клонирует репозиторий, его название в случае если не задается будет взята из конца в [URL/[name]] 
3. code [name]/ - открываем новый созданный репозиторий видим все теже самые ветки, что и у сотрудника передавшего [URL]

### GitHub vs GitLab: сравнение сервисов
1. Github (чаще используется для самостоятельной разработки):
  - Самая популярна платформа для open-source
  - Владеет Microsoft
  - Долгое время не было бесплатных приватных репозиториев
  - Двигается в сторону "социальной сети для разработчиков"
2. Gitlab (чаще используется для командной разработки):
  - Много возможностей бесплатно: организиции, приватные репозитории, CI (Continuous Integration) какая то интерграция
  - Удобные инструменты для командной работы и различных интеграций с сервисами для командной работы
  - Можно бесплатно установить на свой сервер
  - Позиционируется как продукт для больших команд

### Как обычно работает авторизация. SSH-ключи
Существует два вида URL:
1. HTTPS (HyperText Transfer Protocol Secure - расширение протокола HTTP для поддержки шифрования в целях повышения безопасности):
  - Защищенный протокол, который используется в браузере
  - Авторизация через логин и пароль
  - Небезопасно, потому что можно украсть данные
  - Часто добавляет второй фактор для авторизации (смс, код из приложения)
2. SSH (Secure SHell — «безопасная оболочка», сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов)):
  - Защищенный протокол, используется для общения с сервером
  - Авторизация происходит по 2 ключам: публичному и приватному
  - Приватный ключ может быть с паролем, как дополнительный фактор защиты, НЕ РЕКОМЕНДУЕТСЯ
  - Что бы взломать, нужно получить доступ к компьютеру

SSH хранится на компьютере (запоминать его не нужно), на другом компьютере РЕКОМЕНДУЕТСЯ создать свой SSH ключ, главное не потерять компьютер, никому не отдавать, следить что бы компьютер не украли. 
Принцип работы (как происходит процесс подтверждения, что это именно Вы и например Вам можно запушить сообщение на Server): Вы складываете Ваш Публичный ключ на нужные Вам сервера, далее Server при помощи Публичного ключа зашифровывает сообщение и отправляет на Ваш компьютер, который при помощи Приватного ключа расшифровывает сообщение и отправляет его обратно на Server. Даже если сообщение будет перехвачено, это без толку.

### Как создать SSH-ключ
https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
1. Переходим по ссылке выше и копируем команду: ssh-keygen -t ed25519 -C "your_email@example.com"
2. Открываем терминал Git bash и вставляем туда команду с Вашей почтой и выполняем команду: ssh-keygen -t ed25519 -C "otm_@tut.by"
3. Спрашивают куда хотите сохранить ключ, по умолчанию он сохраняется в папку C:/Users/vitaly/.ssh/id_ed25519 нас это устраивает нажимаем Enter
4. Спрашивают хотите ли использовать пароль, НЕ РЕКОМЕНДУЕТСЯ, поэтому ничего не вводим и нажимаем ENTER
4. Далее спрашивают повторить пароль, снова ничего не вводим и нажимаем ENTER
5. Создается наш ключ SSH
6. cd ~/.ssh - заходим в папку ssh
7. ls -la - смотрим что в ней есть, что бы увидеть все файлы в папке /.ssh и полную информацию о них 
8. ssh-add - сказать ssh-агенту использовать все ключи в папке /.ssh
9. cat id_ed25519.pub - заходим в файл id_ed25519.pub и копируем публичный ключ, что бы присоединить его к Github и Gitlab. ВАЖНО ПЕРЕДАВАТЬ ПУБЛИЧНЫЙ КЛЮЧ id_ed25519.pub
10. Переходим в Github, открываем настройки своего аккаунта Settings (шестеренка) => SSH and GPG keys => New SSH key => в Title даем ему название например test => в поле key вставляем скопированный публичный ключ например: ssh-ed25519 BDGHKKKroD39383894839kfkfkf5d8d9dS otm_@tut.by => Add SSH key. Теперь ключ добавлен в Github и можно использовать Git с Github
10. Переходим в Gitlab, открываем настройки своего аккаунта Preferences => SSH keys => в поле Key вставляем скопированный публичный ключ например: ssh-ed25519 BDGHKKKroD39383894839kfkfkf5d8d9dS otm_@tut.by => в Title даем ему название например test => можно указать дату когда ключ перестанет работать Expiration date можем не указывать => Add key. Теперь ключ добавлен в Gitlab и можно использовать Git с Gitlab
https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection для проверки SSH подключения открываем ссылку и вставляем команду в терминал и проверяем
11. ssh -T git@github.com - проверяем SSH подключение, если все гуд Github назовет Вас по имени (Hi vitalyvitmens! You've successfully authenticated, but GitHub does not provide shell access.)

### Как создать репозиторий и присоединить его к проекту по SSH
1. git init - инициализируем репозиторий
2. Для первого коммита нам нужно сделать мимнимум изменений, что бы если что было проще откатывать изменения и чтото менять, это будет файл например с лицензией LICENSE. На панели с лева в Source Control нажимаем на + в файле LICENSE (он добавится в Staged Changes) и коммитим
3. git commit -m "chore: initial commit" - коммитим файл LICENSE
4. Если какие то файлы нужно добавить в .gitignore, то создаем .gitignore и добавляем в него эти файлы
5. Коммитим все остальное: нажимаем на + в строке Changes и создаем коммит: feat: добавляет шаблон. Далее нажимаем на кнопку Commit
6. Теперь нам нужно этот код отправить на Github, заходим на Github, авторизуемся и создаем новый репозиторий кнопка New или слева от аватара нажимаем +. Далее в Create a new repository называем например: mdl-blog выбираем нужные галочки и настройки, нажимаем Create repository
7. Выбираем SSH напротив него будет URL например: git@github.com:vitalyvitmens/mdl-blog.git
8. Из строки …or push an existing repository from the command line копируем первую строку: git remote add origin git@github.com:vitalyvitmens/mdl-blog.git и выполняем в своем терминале
9. git push - в терминале своем выполняем данную команду, в случае ошибки выполнить: git push --set-upstream origin master, что бы Git знал что origin и master это одна и та же ветка
10. Видим в терминале что ветка создалась: * [new branch]      master -> master
11. Обновляем страницу Github и видим удачное добавление нашего проекта
12. Теперь тоже самое делаем на Gitlab - заходим, авторизуемся => нажимаем кнопку New project или + слева от аватара => Create blank project => выбираем имя для проекта например: mdl-blog => Public => убираем галочку Initialize repository with a README => нажимаем кнопку Create project
13. Копируем третью строку из Push an existing folder: git remote add origin git@gitlab.com:vitalyvitmens/mdl-blog.git, вставляем в свой терминал и меняем в ней название origin на origin-gl и нажимаем Enter: git remote add origin-gl git@gitlab.com:vitalyvitmens/mdl-blog.git
14. git push origin-gl - пушим на Gitlab, в случае ошибки, выбираем yes, в случае повторной ошибки повторно пушим: git push origin-gl
15. Видим в терминале что ветка создалась: * [new branch]      master -> master
16. Обновляем страницу Gitlab и видим удачное добавление нашего проекта

### Что такое issues, как их создавать и как с ними работать
1. Открываем Ваш аккаунт на Github, переходим в нужный проект, открываем вкладку Issues => New issue => в Title описываем что у нас произошло, например: Лишняя кнопка view source => Add your description here...: Нужно удалить кнопку, чтобы пользователи не переходили в чужой репозиторий на Github => Assignees выбираем например себя => Labels задаем метки например что это bug => Projects можно привязать к какому то проекту => можно задать какой то Milestone например новый релиз => Submit new issue - создаем Issue
2. Issue очень похож на задачу в task tracker, в нем можно общаться, можно закрыть Issue - Close issue как выполненный или как тот который не планируете исправлять, можно подписаться или отписаться от уведомлений - Unsubsribe, закрыть обсуждение - Lock conversation и т.д.
3. Открываем Ваш аккаунт на Gitlab, переходим в нужный проект, открываем вкладку Issues => New issue => в Title описываем что у нас произошло, например: Лишняя кнопка view source => Write a descriptio or drag your files here...: Нужно удалить кнопку, чтобы пользователи не переходили в чужой репозиторий на Github => можем выбрать тип Issue или Incident => Assignees выбираем например себя => Labels => Create project label например что это bug и выбираем для него цвет нажимаем кнопку Create => задаём дедлайн до какого числа пофиксить проблему Due date => Projects можно привязать к какому то проекту => можно задать какой то Milestone например новый релиз => Create issue - создаем Issue

### Как создавать pull request и связывать его с issue
1. git checkout -b remove-source-button - переходим в VS-code и в терминале создаем и переключаемся на ветку в которой будем исправлять данную проблему
2. Рефакторим код (удаляем кнопку view-source в index.html) и проверяем что она пропала в браузере
3. Создаём коммит в SOURCE CONTROL в строке Changes нажимаем + => пишем например: fix: удаляет кнопку view source => Commit => в терминале выполняем команду: git push origin | git push --set-upstream origin remove-source-button
4. Переходим на Github в проект, видим что создалась в проекте ветка remove-source-button и Github предлагает автоматически создать Compare & pull request нажимаем эту кнопку => Add a title меняем fix: удаляет кнопку view source на Удаляет кнопку view source => можем назначить ревьюверов (тот кто будет смотреть наш код), Assignees (тот кто делает этот pull request), Lable и др. Часто pull request связан с Issue => в теле указываем что мы фиксим: Исправляет #1 => Create Pull request => кликаем на ссылку нашего issue #1 и переходим видим что в нем появляется обратная ссылка на наш pull request, статус его open
5. Возвращаемся на предыдущую страницу. В pull request есть список коммитов, из какой ветки в какую будет вливание, можно посмотреть код Files changed и даже его проревьюить (возле номера строки изменений в коде нажать +) и оставить комментарий, например: Спасибо, что удалил! => Add single comment => комментарий будет виден на главной странице pull request
6. После прохождения ревью можно принять или отвергнуть pull request => далее переходим на главную (вкладка Conversation в pull request)
7. После нажатия кнопки Merge pull request и подтверждения Confirm merge наши изменения из ветки remove-source-button окажуться в master 
8. Наш pull request переходит в статус Merged можем сразу удалить ветку Delete branch => переходим в наш код на master и смотрим что в index.html нет кнопки view sourse, а так же что на index.html повлиял коммит: fix: удаляет кнопку view source
9. Переходим в issue И видим статус Merged
10. Закрываем Issue как выполненный => Close issue и он закрывается => переходим во вкладку Issues и видим что у нас нету ни одного открытого и один закрытый issue 
11. Теперь то же самое проделаем на Gitlab
12. git push origin-gl - в терминале выполняем данную команду, после в терминале открываем ссылку remote:   https://gitlab.com/vitalyvitmens/mdl-blog/-/merge_requests/new?merge_request%5Bsource_branch%5D=remove-source-button     
13. title меняем fix: удаляет кнопку view source на Удаляет кнопку view source
14. в теле указываем что мы фиксим: Исправляет #1
15. выбираем Merge options с галочкой Delete source branch
16. нажимаем на строчку кода и выбираем сообщение что бы комментировать, например Comment test => Add comments now
17. Вливаем мердж реквест => Overview => Merge
18. По ссылке переходим в сам issue нажав на решетку в Mentions issue #1
19. Далее можем закрыть issue для этого нажимаем кнопку Close issue

### Что такое fork, когда он нужен и как с ним работать
https://lk.result.school/pl/teach/control/lesson/view?id=285571404
1. Github Нажимаем кнопку Fork (Fork - копия чужого репозитория) выбираем куда форкаем, называем например fork-example => выбираем какую ветку копируем обычно master | main => Create Fork 
2. Копируем ссылку уже своего форкнутого репозитория в Code по SSH
3. git clone git@github.com:vitalyvitmens/mdl-blog.git - клонируем у себя в терминале
4. в vs-code вносим изменения, например добавляем файл .DS_Store в .gitignore + обязательно его удалить в терминале команда git rm .DS_Store теперь этот файл не отслеживается гитом
5. git commit -m "fix: добавляет игнорирование DS_Store"
6. git push - пушим в свою копию репозитория
7. в Github увидим сообщение что наша ветка впереди на один коммит по отношению к той ветке с которой форкали
8. нажимаем кнопку contribute => Open pull request => описываем что произошло и указываем откуда куда вливаем (см стрелочку) => Create pull request

### GitHub Pages - бесплатный хостинг для вашего frontend-проекта
https://lk.result.school/pl/teach/control/lesson/view?id=285571405
1. Если Ваш код статический и его не нужно собирать:
Github => project => settings => pages => Source (Deploy from a branch) => Branch (master) (/(root)) => Save => Code => Actions (выяснить собралась страница и выложилась или нет) 
2. Если Ваш код нужно собирать (2 пути: Github Actions | собирать код локально и выкладывать с помощью готового пакета):
  - на локальном компьютере в проекте создаем директорию dist и перемещаем все наши файлы и папки | с помощью скрипта npm run build собрали dist
  - npm init -y
  - npm install gh-pages --save-dev - устанавливаем пакет gh-pages
  - в файл package.json в "scripts": добавляем поле: "deploy": "gh-pages -d dist" который запускает gh-pages и говорит, что нужно деплоить папку dist
  - npx gh-pages --help - чтобы посмотреть какие опции есть у gh-pages
  - npm run deploy
  - заходим в свой проект на Github => Code. Видим что появилась ветка gh-pages переходим на нее и видим что в ней толкьо 1 коммит Updates, а это значит что история у этой специальной ветки не сохраняется => Settings => Pages => Branch (gh-pages) => Save => Actions (видим запуск нового деплоя) => pages build and deployment => видим что деплоу создался и открыв старницу все так же без изменений, если хотим убедиться что теперь деплоу происходит из gh-pages, для этого откатим все назад и изменим в коде название title
  - SOURCE CONTROL => в Changes вторая стрелка по кругу без плюса с всплывающей подсказкой: Discard All Changes => Discard All 428 Files => удаляем папку Dist => в index.html меняем title с Material Design Lite на MDL => сохраняем => создаем коммит и отправляем 

### Версионирование пакетов: semantic version
1. Версия состоит из трех частей разделяющихся точками (при изменении версии, все находящие за точкой сбрасываются на 0):
  - мажорная (когда ломается обратная-совместимость, пользоваетль не сможет установить у себя пакет и продолжить пользоваться, например breaking changes)
  - минорная (когда приносим новую функциональность, например feat)
  - патч (меняем когда сделали какие то обратно-совместимые изменения, ничего не сломали и не принесли новой функциональности, например fix, chore, docs)

### Теги - метка важного этапа в жизни проекта
1. git tag - проверяем что никаких тегов у нас нет
2. git tag 1.0.0 - создаем легковесный тег (без дополнительной информации, просто с указанием на коммит)
3. git show 1.0.0 - посмотреть тег 1.0.0
4. git tag -a test -m "test release" - создаем анатированные теги (которые содержат дополнительную информацию)
5. git tag - проверяем что теперь у нас два тега
6. git show test - смотрим на тег test
7. git push --tags - отправить теги на Github
8. git tag -d test - локально удаляем тег test
9. git tag - проверяем что теперь у нас один тега
10. git push origin --delete test - удалить тег test в удаленном репозитории

### Релизы: как создавать и управлять
1. Чтобы создать релиз в Github => Code => Tags => Releases => Create a new release => Choosw a tag (1.0.0) => Release title (1.0.0) => Describe this release (Инициализировали проект и подготовили к продакшну) => Generate release notes => Publish release

### Различные flow
1. Git flow:
  - основная ветка - master
  - от master отводится ветка develop для влития выполненых задач
  - разработка ведётся в ветках feature (например: feature/new-header), отведенных от develop
  - когда мы готовы к релизу, то от develop отводим ветку release
  - когда протестировали release вливаем его в develop и master, в master создаём тег указывающий на конкретный релиз
  - хотфиксы отводятся от master, а вливаются в master и develop, в master создаём тег
2. GitHub flow:
  - основная ветка - master
  - разработка ведётся в ветках feature (например: feature/new-header), отведенных от master
  - когда мы готовы к релизу, то master выкатывается в продакшн, в master создаём тег указывающий когда мы выкатили в продакшн и его же поставить на наше продакшн окружение
  - хотфиксы отводятся от master, вливаются в master, в master создаём тег и выкладываем этот код в продакшн
3. GitLab flow:
  - основная ветка - master
  - разработка ведётся в ветках feature (например: feature/new-header), отведенных от master
  - когда мы готовы к релизу, то master вливаем в ветку production
  - хотфиксы отводятся от master, вливаются в master

### Как работать по GitHub flow  
1. git checkout -b feature/remove-description - разработчик №1 от ветки master отводит свою ветку feature/remove-description и производит в ней свои изменения, например удаляет description
2. git add .
3. git commit -m "feat: удаляет description" - разработчик №1 создаёт коммит с его изменениями
4. git push - разработчик №1 отправляет изменения в Github
5. remote:   https://gitlab.com/vitalyvitmens/origin/pull/new/feature/remove-description - разработчик №1 в терминале сразу предлагается создать pull request, переходим по ссылке => Create pull request => Pull requests => feat: удаляет description => Files changed (Например нужно начать обсуждения) => (напротив строки кода нажимаем +) => Leave a comment (Точно ли нужно удалить description, а не только текст внутри?) => Add single comment => Review changes => Conversation => Merge pull request => Confirm merge => Code
6. Разработчик №2 находясь на ветке master берет задачу на изменение title
7. git checkout -b feature/change-title - разработчик №2 от ветки master отводит свою ветку feature/change-title и производит в ней свои изменения, например изменяет title
8. git add .
9. git commit -m "feat: изменяет title" - разработчик №2 создаёт коммит с его изменениями
10. git push - разработчик №2 отправляет изменения в Github
11. remote:   https://gitlab.com/vitalyvitmens/origin/pull/new/feature/change-title - разработчик №2 в терминале сразу предлагается создать pull request, переходим по ссылке => Create pull request => Pull requests => feat: изменяет title => Merge pull request => Confirm merge => Code
12. git checkout master - разработчик №3 будет выкатывать релизить переключается на master
13. git pull - разработчик №3 пулит самое актуальное состояние 
14. git checkout -b release/1.0.0 - разработчик №3 отводит релизную ветку
15. разработчик №3 внутри файла package.json над строкой "private" задает версию: "version": "1.0.0",
16. git add .
17. git commit -m "chore: release" - разработчик №3 создаёт коммит с его изменениями
18. git push - разработчик №3 отправляет изменения в продакшн, если эта работа настроена через npm script и тогда именно в ээтот момент запускается этот npm script у кого то это происходит через CI - при пуше релизной ветки происходит выкладка в продакшн, предположим что в нашем случае выкладка и сборка происходит при пуше в определенную ветку, которая начинается с release/1.0.0
19. remote:   https://gitlab.com/vitalyvitmens/origin/pull/new/release/1.0.0 - разработчик №3 в терминале сразу предлагается создать pull request, переходим по ссылке => Create pull request (и не вливаем его до тех пор пока релиз не окажется в продакшене) => Merge pull request => Confirm merge => Code

### Правила командной работы на практике
Например Вы отвели ветку test от master и что то сделали в своей ветке test и Вам нужно влить свои изменения в master, но в это время другие разработчики накоммитили в мастер
1. Вы установили пакет будстрап в свое приложение и нас попросили вернуть зря удаленный description и изменить title
2. git add .
3. git commit -m "feat: добавляет react-bootstrap"
4. git push
5. git add .
6. git commit -m "fix: изменяет title"
7. git push
8. remote:   https://gitlab.com/vitalyvitmens/origin/pull/new/test - Вам в терминале сразу предлагается создать pull request, переходим по ссылке и видим Can't automatically merge (ветка не может быть вмёрджена у нас конфликты в нескоьких файлах, мы можем пофиксить их в гитхабе нажав Resolve conglicts, но лучше в VS-code)
9. Переходим в терминал VS-code что бы пофиксить конфликты:
10. git checkout master
11. git pull 
12. git checkout -      - переключаемся на ту ветку где были до этого, на ветку test
13. git rebase master - ребайзимся на мастер и видим что у нас есть несколько конфликтов. 
14. Бывает 2 типа конфликтов: 
  1. Когда чтото поменялось в функциональности. При устранении данных мердж конфликтов главное удалить <<<<<<< ========== >>>>>>> и помнить в верху то что в master суйчас, снизу то что у Вас в test сейчас:
    - Accept Current Change (принять то что сверху)
    - Accept Incoming Change (принять то что снизу)
    - Accept Both Changes (принять всё)
    - Compare Change ()
    - Ctrl + S - сохраняем файл 
  2. Конфликты в сгенерированных файлах например package-lock.json:
    - Github => Code => package.json => Blame (увидим когда какие коммиты что меняли и поймем, что самым последним было изменение с добавление бутстрап реакт и понимаеч что кто тоже хотел добавить бутсрап и ошибся добавил не тот пакет) => VC-Code
    - переходим в package.json, удаяем из него зависимость (строку с бутстрап реакт) и запускаем npm i Так как у нас сломан package-lock.json, то npm автоматически попробует разрезолвить конфликты, если у него получиться то мы получим правильный package-lock.json, если не получиться то npm создаст новый package-lock.json
15. git add . - добавляем наши изменения
16. git rebase --continue - продолжаем ребэйз, откроется интерактивное окно, закроем его тем самым подтверждая изменения, отлично мы все исправили осталось запушить
17. git push -f - мы не можем просто так запушить, мы изменили хэш коммита и git не понимает куда поставить этот новый коммит, а самое главное куда деть старый, поэтому -f или --force
18. Github => Pull requests => feat: изменяет title и добавляет react-bootstrap => видим что у нас все хорошо и можно мерджить, но допустим у нас произошли какие то изменения на master
19. git checkout master
20. В ветке master в package.json поменялась версия "version": "1.0.1",
21. git add .
22. git commit -m "chore: release"
23. git push
24. После внесения изменений в master наш Pull request пересчитается, желтая плашка покажет что в настоящий момент пересчитывает, если конфликтов нет, то будет зеленая кружок с галочкой и можно мерджить => Github => Pull requests => feat: изменяет title и добавляет react-bootstrap => Merge pull request (выбираем например: Rebase and merge) => Confirm merge => Code => commits (видим что у нас нет коммита Merge pull request..... а есть коммит feat: изменяет title и добавляет react-bootstrap как будто мы его сделали прям в master. Можно выбирать любую из понравившихся стратегий мерджа внутри Github)

### Как сделать вклад в open-source 
1. Есть сайт куда можно зайти и найти проект и проблему себе по душе https://goodfirstissue.dev
2. Слева выбираем язык программирования например typescript https://goodfirstissue.dev/language/typescript
3. Видим проекты которые нуждаются в Вашей помощи, можно выбрать какой то звездный проект что бы помощь этому проекту внести себе в резюме 
4. Например выбираем проект facebook / docusaurus => 7 issues => Первая задача (https://github.com/facebook/docusaurus/issues/5691)  
5. Смотрим Labels видим good first issue - по этому тегу сайт https://goodfirstissue.dev находит такие задачи если есть еще Label со статусом status: claimed - это значит, что задача уже кем то занята и по обсуждению можно найти того кто её делает 
6. Допустим задача не занята и мы беремся за нее:
7. Делаем Fork (наш клон) данного репозитория, после создания клона клонируем этот репозиторий к себе по ssh:
  - Code => Fork => Create fork
8. git clone git@github.com:vitalyvitmens/docusaurus.git
9. code docusaurus/ - открываем его в редакторе VS-Code
10. и вносим необходимые изменения, так как мы эксперементируем просто допишем что нибудь в REDME.md
11. git add .
12. git commit -m "test"
13. git push - пушим в наш Fork (созданный путем клонирования нашего репозитория)
14. В репозитории могут быть 2 файла:
  - CONTRIBUTING.md - описывает как нужно контрибьютить
  - CODE_OF_CONDUCT.md - соглашение как мы общаемся внутри проекта, внутри issues и pull requests и т.д.
15. GitHub => Contribute => Open pull request (здесь уже подставлено какое то содержание нашего pull request его нужно прочитать и отметить чекбоксы что ознакомились) => Create pull request => далее откроется диалог с разработчиками с закидыванием комментариев по вашему коду
16. Если нашли баги без goodfirstissue: Issues => New issues => Bug Report => Если есть форма читаем и заполняем, если нет то сами расписываем очень досконально => Submit new issue Можно также указать, посмотрите если это баг, то я исправлю и пришлю пулл реквест

### Передача изменений по элетронной почте при помощи PATCH (полезно когда репозиторий закрытый, но нужно поделиться изменениями с другими разработчиками)
1. git diff [hash_commit] > my_patch.patch - данная команда находит коммит по хэшу коммита и сохраняет его в виде файла my_patch.patch в нужную дирректорию, затем файл можно отослать по эл почте. Что бы посмотреть хэш коммита используй git log. Название файла патча может быть любым, но рекомендуется указывать расширение .patch
2. git apply my_patch.patch - затем принимающая сторона получает файл, добавляет его в проект и выполняет данную команду, что бы применить данный патч, который удалится из файловой системы при его применении
3. git status - при помощи данной команды смотрим какие именно применились изменения
4. git restore . - что бы отменить все примененные патчем изменения и в ручную удалить появившийся лишний .gitignore
5. git format-patch [hash_commit] - данная команда более автоматизированная, она кроме того что делается в пункте 1. передает еще и коммиты
6. git apply ./patches/* - принимающая сторона слаживает все полученные файлы с расширением .patch в папку patches и при помощи данной команды автоматически применяет изменения в коде включая добавление коммитов
7. git restore . - при желании можно снова откатить эти патчевые изменения и в ручную удалить лишний появившийся .gitignore
8. git am ./patches/* - ЕЩЁ КРУЧЕ КОМАНДА, она не просто применяет изменения как в пунктах 1. и 5. но еще и позволяет считывает инфу из коммитов об авторах и т.д. и сразу создает коммиты
9. git log - убеждаемся что коммиты сразу применились

#### Создание веток
1. git branch - проверяем сколько у нас веток и какие
2. git branch develop - создаём ветку develop для разработки
3. git branch feature/main-page - создаём ветку main-page для разработки главной страницы
4. git branch feature/about-company - создаём ветку about-company страница о компании
5. git checkout develop - переход на ветку develop
6. git branch - проверяем сколько у нас веток и какие * зеленый цвет - на какой ветке находимся
7. git push [rep_link] [branch_name] (git push origin develop) - запушить коммит с другой ветки. Чтобы глянуть [rep_link] [branch_name] используй команду git remote -v
8. git checkout -b develop origin/develop - pull ветки develop с удаленного репозитория и переход на нее

#### Слияние веток при помощи действия pull request - делается через GitHub https://lk.result.school/pl/teach/control/lesson/view?id=268066813&editMode=0

#### Слияние веток при помощи команды git merge
1. git branch - проверяем сколько у нас веток и какие
2. git branch test - создаём ветку develop для разработки
3. git branch -d test - удалить ветку test
4. git branch feature/main-page - создаем ветку для разработки главной страницы
5. git checkout feature/main-page - переходим на ветку для разработки главной страницы и создаем изменения
6. git checkout main - возвращаемся на ветку main !!! обязательно !!!
7. git merge feature/main-page - указываем название ветки (feature/main-page) чей код мы хотим переместить в нашу главную ветку main, после этого изменения из ветки feature/main-page отобразятся на главной ветке main
8. git push origin main - пушим изменения на удаленный репозиторий (в нашем случае GitHub)
9. git branch -d feature/main-page - удаляем локально ветку feature/main-page
10. Так же необходимо удалить ветку в удаленном репозитории (в нашем случае GitHub). Для этого переходим в секцию branches и в блоке Your branches напротив feature/main-page нажимаем кнопку delete, так же есть возможность ее восстановить если нажать кнопку Restore
11. git branch - проверяем сколько у нас веток и какие

#### Решение конфликтов при слиянии веток
1. git branch - проверяем сколько у нас веток и какие
2. git branch feature/user-access - создаем новую ветку feature/user-access
3. git branch - проверяем сколько у нас веток и какие
4. git checkout feature/user-access - переходим на ветку feature/user-access и создаем там новую фичу и коммитим изменения:
- git add .
- git commit -m "first commit in branch feature/user-access" 
5. git checkout main - переходим на главную ветку main и создаем там новую фичу (как будто два разработчика одновременно написали похожий код в тех же строках но в разных ветках) и коммитим изменения:
- git add .
- git commit -m "add data in branch main" 
6. git marge feature/user-access - пытаемся смерджить (слить) ветку feature/user-access в main, но появляются конфликты, фиксим их:
- Accept Current Change - принять изменения из ветки main
- Accept Incoming Change - принять изменения из ветки feature/user-access
- Accept Both Changes - принять изменения из обоих веток
7. Коммитим изменения:
- git status
- git add .
- git commit -m "add data in branch main" 
- git push origin main - пушим изменения на удаленный репозиторий (в нашем случае GitHub)
8. git branch -d feature/user-access - удаляем локально ветку feature/user-access
9. git branch - проверяем сколько у нас веток и какие
