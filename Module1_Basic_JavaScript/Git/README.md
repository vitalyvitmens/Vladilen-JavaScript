1. git status - глянуть статус, показывает что у нас сейчас происходит в рабочем дереве гита, дает более оперативную инфу чем VS-code
2. git add [files] || git add [folder] || git add . - добавляет файлы в stage (этап = промежуточная область)
3. git commit -m "comment" - закомитить файлы добавленные в stage (этап = промежуточная область)
4. git commit -m "comment" -a || git commit -m "comment" --all - закоммитить всё что у нас есть
5. git log - глянуть подробную инфу (логи) о наших коммитах, на каком комите находимся, где у нас находится main ветка. Клавиша q - выйти из git log
6. git log --oneline - глянуть краткие логи коммитов (id коммита + название коммита)
7. git config user.name - глянуть автора
8. git config user.email - глянуть почту автора
9. git remote -v - узнать есть ли удаленный репозиторий
10. git remote origin url - привязать локальный гит к удаленному (github) гиту
11. git push [rep_link] [branch_name] || git push
- [rep_link] = git remote -v = origin = https://github.com/vitalyvitmens/Vladilen-JavaScript
- [branch_name] = git branch = main
- gip push origin main
12. git reset [files] - что бы убрать со stage определенный файл 
13. git diff - посмотреть изменения
14. git reset --hard - уберет все изменения и вернет то что было до последнего push
15. git restore [files] - уберет все изменения в файле и вернет то что было до последнего коммита в этой ветке
16. git restore --staged [file] - выбросит файл из коммита

### Правильное оформление коммитов https://www.conventionalcommits.org/en/v1.0.0/
1. В терминале открываем терминал powershell || bash || zsh и пишем команду: git commit -a
2. В открывшемся новом окне редактора кода пишем коммит состоящий из header body footer:

fix(Module1_Basic_JavaScript\Git\README): изменяет текст

В мидл курсе вскрылись новые способности Git

https://www.conventionalcommits.org/en/v1.0.0/

3. Что бы редактор кода открывался в новом окне после команды git commit -a, настраиваем редактор запуском команды в терминале:
git config --global core.editor "code --wait -n"

### Откатить commit например если забыл создать файл .gitignore и сдуру запушил лишнего
1. git rm -rf --cached .
2. git add .
3. git commit -m "fix gitignore"

### Что бы git перестал отслеживтаь какой то файл
1. git rm --cached [files]

### Что бы сохранить наши изменения и временно работать на версии кода без этих изменений
1. git add . - добавляем все наши изменения
2. git stash - убирает (откатывает) наши изменения в stash (временное хранилище куда можно перевести все отслеживаемые файлы, перед этим их обязательно нужно добавить при помощи git add .)
3. git stash list - что бы заглянуть внутрь stash (временного хранилища)
4. git stash pop - возвращает наши изменения, вытаскиваем последнюю запись из stash, что бы их закомитить после вытаскивания используй команду git add .
5. git stash pop - удалить из stash последнюю запись
6. git stash drop - удалить все записи из stash
7. git stash apply - применить изменения не удаляя изменения из stash
8. git stash apply stash@{0} - применить нулевую запись находящуюся в stash, перед этим посмотри идентификатор нужной записи (stash@{0}) при помощи команды git stash list


### Редактирование коммитов в том числе ошибочных коммитов
1. git commit --amend - флаг --amend позволяет как то поменять коммит + может менять и код вместе с изменением коммита, но он годится только для одного разработчика, разрабатывающего только на одном компьютере
2. git commit --amend --no-edit - меняет код без изменения названия коммита, но он годится только для одного разработчика, разрабатывающего только на одном компьютере
3. git log - посмотреть успешность изменения коммита и др инфу, обрати внимание хэш коммита тоже меняется, поэтому это не годится для коммандной разработки или одиночной, но на нескольких устройствах

### Как работает git: папка .git
1. ls -la - выполните команду в терминал Git bash, что бы увидеть все файлы git и полную информацию о них
2. code .git - открывает папку .git в редакторе кода, откроются папки гита:
  - hooks - папка хранит файлы выполняемые на какие то события, например перед коммитом, перед пушем и тд
  - info - папка в которой хранится файл exclude, в нем можно указть какие то файлы которые будут работать как .gitignore
  - logs - в этой папке хранится лог всех событий, в файле HEAD хранится все что происходило
  - Objects - это хранилище гита, не удалять, а то сломается гит
  - refs - в этой папаке хранится информация, о том куда указывают разные ветки, например ветка main (.git/refs/heads/main) указывает на коммит хэшом коммита, например: aacd1343734c92cff53e084d1e512327b7fd25fa, можно перейти в терминал и выполнить git log затем скопировать хэш коммита и убедиться что он аналогичен данному хэшу ветки main
  - COMMIT_EDITMSG - это файл, содержащий последнее сообщение коммита которое мы редактировали
  - config - файл различных конфигураций
  - description - описание для репозитория если, именованный репозиторий есть
  - HEAD - указывает где мы сейчас находимся ref: refs/heads/main
  - ORIG_HEAD - ссылается на тот же хэш коммита, что и .git/refs/heads/main aacd1343734c92cff53e084d1e512327b7fd25fa
  - index - бинарный файл используемый гитом

### Как смотреть историю: git log
1. git log - увидим хэш коммита, автора коммита, дату создания, описание коммита
2. git log -p - увидим что конкретно было сделано внутри коммита (подходит к атомарным коммитам, когда часто коммитятся малые изменения)
3. git log --stat - что бы узнать насколько ббольшой или маленький был коммит и не хочется смотреть patch
4. git log --pretty=oneline - можно форматировать в каком виде будет предоставлена информация истории коммита (oneline - формат один коммит в одну строку)
5. git log --pretty=format:"%h (%ae): %s" - можно пользовательски форматировать в каком виде будет предоставлена информация истории коммита (%h - хэш коммита, (%ae): - автор коммита, %s - текс коммита)
6. GitLens - расширение в VS-code позволяющее например нарисовать граф коммитов

### Как менять историю коммита: git reset/revert
1. git log - копируем хэш коммита который следует откатить
2. git revert [hash_commit] - откроется редактор который предложит изменить заготовленное сообщение для этого коммита. НЕ РЕКОМЕНДУЕТСЯ так как добавит новый комит после изменяемого
3. git reset HEAD~1 - откатиться назад на 1 (один) коммит
4. git reset [hash_commit] - откатиться назад к коммиту с хэшом [hash_commit] указанным в команде
5. git reset [hash_commit] --hard - откат назад к коммиту с хэшом [hash_commit] указанным в команде и сброс всех изменений
6. git reset [hash_commit] --soft - ПРЕДПОЧТИТЕЛЬНЫЙ ВАРИАНТ, откат назад к коммиту с хэшом [hash_commit] указанным в команде без потери изменений в Staged Changes с возможностью переложить изменения в другие коммиты
7. git reset [hash_commit] --mixed - ПРЕДПОЧТИТЕЛЬНЫЙ ВАРИАНТ, откат назад к коммиту с хэшом [hash_commit] указанным в команде с потерей изменений в Staged Changes, но без потери самих изменений 
8. GitLens - расширение в VS-code позволяет откатить коммит нажав на стрелку по кругу

### Как редактировать старые коммиты: git rebase для коммитов
1. Открываем GitLens => COMMITS => Working Tree и копируем [SHA] необходимого коммита
2. git rebase [SHA] -i - задает [SHA] от которого дальше руками будем перестраивать дерево, импользуется для редактирования истории внутри одной ветки или наслаивания ветки на ветку. В VS-code откроет GitLens interactive Rebase который позволит что то делать с коммитами, что бы переключиться на текст SWITCH TO TEXT с описанием всех команд. что бы склеить 2 коммита вместе склеиваемый перемещаем под тот с которым надо склеить и выбираем комнаду pick - если сохранить и закрыть, то коммиты пересортируются в дереве коммитов согласно новым местам, но еще не склеються, для склейки у склеиваемого коммита нужно поменять pick на squash (но остануться 2 строчки коммит месседж) | fixup (как squash, но только выкидывает коммит месседж. ПРЕДПОЧТИТЕЛЬНО)
Если нужно удалить коммит выбираем команду drop - удалит данный коммит
Если нужно редактировать коммит выбираем команду edit
После выбора сохраняем и закрываем, далее мы находимся в процессе ребэйса он еще не закончен, можем добавить что то в коммит, после добавления выполняем git add . + git commit --amend --no-edit, а когда закончили с изменениями выполняем команду git rebase --continue, дальше сталкиваемся с ситуацией когда возникает merge конфликт (коммит не может наложиться на предыдущий), разделителем двух состояний является ============== . Вверху выбираем Accept Both Changes (принять оба изменения убрав все разделители) и далее удаляем, то что не нужно. Сохраняем этот файл. Делаем git add . А затем git rebase --continue Продолжаем ребэйс закрываем файл и ребэсы продолжаются. Открываем GitLens => COMMITS и проверяем что изменения применились.
НЕ ЗАБЫВАЙТЕ в случае работы с одной веткой использовать интерактивный режим -i ребэйса: git rebase [SHA] -i

### Как переключаться между коммитами: git checkout (можно переключаться между коммитами по их хэшу [SHA]) Подходит для тестирования кода проекта, так как режим detached и можно не сохранять изменения и легко вернуться в предыдущее состояние main
1. Открываем GitLens => COMMITS => Working Tree и копируем [SHA] необходимого коммита
2. git checkout [SHA] - перейдем на тот коммит при котором например, по заявлениям коллеги повились баги и проверяем были ли баги при этом коммите или не было. HEAD показывает где во времени коммитов в дереве мы находимся, находимся в режиме detached HEAD (в подвешенном состоянии, когда созданные коммиты будут подвешены в воздухе, можно делать эксперементальные изменения коммитить их изменять для этого применяем команду: git commit -m "chore: описываем что поменяли" -a, это создаст отдельную ветку, отдельно от main и если переключимся обратно на ветку main: git checkout main, то они не применятся, но и не пропадут их можно отыскать в случае необходимости и создать новую ветку git branch [new-name-branch] [SHA] или переключиться на данный коммит снова git checkout [SHA] или создать ветку и переключиться на нее git switch -c [new-name-branch]).


### Передача изменений по элетронной почте при помощи PATCH (полезно когда репозиторий закрытый, но нужно поделиться изменениями с другими разработчиками)
1. git diff [hash_commit] > my_patch.patch - данная команда находит коммит по хэшу коммита и сохраняет его в виде файла my_patch.patch в нужную дирректорию, затем файл можно отослать по эл почте. Что бы посмотреть хэш коммита используй git log. Название файла патча может быть любым, но рекомендуется указывать расширение .patch
2. git apply my_patch.patch - затем принимающая сторона получает файл, добавляет его в проект и выполняет данную команду, что бы применить данный патч, который удалится из файловой системы при его применении
3. git status - при помощи данной команды смотрим какие именно применились изменения
4. git restore . - что бы отменить все примененные патчем изменения и в ручную удалить появившийся лишний .gitignore
5. git format-patch [hash_commit] - данная команда более автоматизированная, она кроме того что делается в пункте 1. передает еще и коммиты
6. git apply ./patches/* - принимающая сторона слаживает все полученные файлы с расширением .patch в папку patches и при помощи данной команды автоматически применяет изменения в коде включая добавление коммитов
7. git restore . - при желании можно снова откатить эти патчевые изменения и в ручную удалить лишний появившийся .gitignore
8. git am ./patches/* - ЕЩЁ КРУЧЕ КОМАНДА, она не просто применяет изменения как в пунктах 1. и 5. но еще и позволяет считывает инфу из коммитов об авторах и т.д. и сразу создает коммиты
9. git log - убеждаемся что коммиты сразу применились

#### Создание веток
1. git branch - проверяем сколько у нас веток и какие
2. git branch develop - создаём ветку develop для разработки
3. git branch feature/main-page - создаём ветку main-page для разработки главной страницы
4. git branch feature/about-company - создаём ветку about-company страница о компании
5. git checkout develop - переход на ветку develop
6. git branch - проверяем сколько у нас веток и какие * зеленый цвет - на какой ветке находимся
7. git push [rep_link] [branch_name] (git push origin develop) - запушить коммит с другой ветки. Чтобы глянуть [rep_link] [branch_name] используй команду git remote -v
8. git checkout -b develop origin/develop - pull ветки develop с удаленного репозитория и переход на нее

#### Слияние веток при помощи действия pull request - делается через GitHub https://lk.result.school/pl/teach/control/lesson/view?id=268066813&editMode=0

#### Слияние веток при помощи команды git merge
1. git branch - проверяем сколько у нас веток и какие
2. git branch test - создаём ветку develop для разработки
3. git branch -d test - удалить ветку test
4. git branch feature/main-page - создаем ветку для разработки главной страницы
5. git checkout feature/main-page - переходим на ветку для разработки главной страницы и создаем изменения
6. git checkout main - возвращаемся на ветку main !!! обязательно !!!
7. git merge feature/main-page - указываем название ветки (feature/main-page) чей код мы хотим переместить в нашу главную ветку main, после этого изменения из ветки feature/main-page отобразятся на главной ветке main
8. git push origin main - пушим изменения на удаленный репозиторий (в нашем случае GitHub)
9. git branch -d feature/main-page - удаляем локально ветку feature/main-page
10. Так же необходимо удалить ветку в удаленном репозитории (в нашем случае GitHub). Для этого переходим в секцию branches и в блоке Your branches напротив feature/main-page нажимаем кнопку delete, так же есть возможность ее восстановить если нажать кнопку Restore
11. git branch - проверяем сколько у нас веток и какие

#### Решение конфликтов при слиянии веток
1. git branch - проверяем сколько у нас веток и какие
2. git branch feature/user-access - создаем новую ветку feature/user-access
3. git branch - проверяем сколько у нас веток и какие
4. git checkout feature/user-access - переходим на ветку feature/user-access и создаем там новую фичу и коммитим изменения:
- git add .
- git commit -m "first commit in branch feature/user-access" 
5. git checkout main - переходим на главную ветку main и создаем там новую фичу (как будто два разработчика одновременно написали похожий код в тех же строках но в разных ветках) и коммитим изменения:
- git add .
- git commit -m "add data in branch main" 
6. git marge feature/user-access - пытаемся смерджить (слить) ветку feature/user-access в main, но появляются конфликты, фиксим их:
- Accept Current Change - принять изменения из ветки main
- Accept Incoming Change - принять изменения из ветки feature/user-access
- Accept Both Changes - принять изменения из обоих веток
7. Коммитим изменения:
- git status
- git add .
- git commit -m "add data in branch main" 
- git push origin main - пушим изменения на удаленный репозиторий (в нашем случае GitHub)
8. git branch -d feature/user-access - удаляем локально ветку feature/user-access
9. git branch - проверяем сколько у нас веток и какие
